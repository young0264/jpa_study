- 7장_고급매핑(22.11.03)
    
    ### **[1] 상속관계 매핑**
    
    - 관계형 데이터베이스에는 객체지향에서 다루는 상속이라는 개념이 없다.
    - 하지만 슈퍼타입 서브타입이라는 모델링 기법이 객체의 상속과 유사하다.
    1. 주요 어노테이션 
        - `@DiscriminatorColumn(name=“DTYPE”)`
        - `@DiscriminatorValue(“XXX”)`
        - `@Inheritance(strategy= InheritanceType.XXX) XXX = 전략`
            - 부모 클래스에 작성
    2. (1)**조인 전략** (각각 테이블로 변환)
        
        ![스크린샷 2022-11-03 10.05.36.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8b3d1230-28e3-4c85-927b-05c65233113e/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-11-03_10.05.36.png)
        
        - `@Inheritance(strategy= InheritanceType.*JOINED*)` 어노테이션 사용
        - 장점
            - 테이블의 정규화
            - 저장공간 효율화
        - 단점
            - 조회시 조인을 많이 사용 → 성능 저하, 조회 쿼리의 복잡함
            - 데이터 저장시 INSERT SQL 2번 호출
    3. (2)**단일 테이블 전략** (통합 테이블로 변환)
        
        ![스크린샷 2022-11-03 10.05.54.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d81e0bbb-e75d-4f27-8d5b-fc74aa548404/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-11-03_10.05.54.png)
        
        - `@Inheritance(strategy= InheritanceType.SINGLE_TABLE)` 사용
        - 장점
            - 조회시 조인을 사용하지 않아 일반적으로 조회 성능이 가장 빠름
            - 조회 쿼리가 단순함
        - 단점
            - 자식 엔티티가 매핑한 컬럼은 모두 null 허용
            - 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다. 상황에 따라서 조회 성능이 오히려 느려질 수 있다.
    4. (3)**구현 클래스마다 테이블 전략** (서브타입 테이블로 변환)
        
        ![스크린샷 2022-11-03 10.06.19.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/584793f5-5bfd-4733-8629-2047d6d5e12e/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-11-03_10.06.19.png)
        
        - `@Inheritance(strategy= InheritanceType.TABLE_PER_CLASS)` 사용
        - 장점
            - 서브 타입을 명확하게 구분해서 처리할 때 효과적
            - not null 제약조건 사용 가능
        - 단점
            - 비추천
            - 여러 자식 테이블을 함께 조회할 때 성능이 느림(UNION SQL 필요)
            - 자식 테이블을 통합해서 쿼리하기 어려움
    
    ### [2] @MappedSuperclass
    
    - (아래의 예)공통 매핑 정보가 필요할 때 사용(id,name)
        
        ![스크린샷 2022-11-03 10.08.18.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/aadd86c3-a46e-4250-a609-28f9038361ea/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-11-03_10.08.18.png)
        
    - 상위 부모 클래스에 붙이는 어노테이션 ( 공통된 속성, 상속)
    - 엔티티X, 테이블매핑X, 조회 검색불가(ex:em.find(추상클래스)불가)
    - 테이블과 관계 없고 엔티티가 공통으로 사용하는 매핑 정보를 모으는 역할
    - 주로 등록일, 수정일, 등록유저, 수정유저 같은 전체 엔티티에서 공통으로 적용되는 정보를 모을 때 사용
    - 추상클래스의 특성과 같이 상속받은 모든 자식 클래스는 추상클래스의 column들을 사용해야함
        
        → 객체지향적으로 공통된 부분은 의무적으로? 사용해라
        
    
    ### [3] 복합키와 식별 관계 매핑
    
    - 식별
        - 부모테이블의 기본키를 받아서 자식 테이블의 기본키+외래키로 사용하는 관계
        - 복합키를 사용하기 때문에 코드가 복잡함(손자 클래스는 JoinCoulmn 2번사용)
    - 비식별
        - 부모 테이블의 기본키를 받아서 자식 테이블의 외래키로만 사용하는 관계
        - JPA에서는 @GenerateValue 처럼 대리키를 생성하기 위한 편리한 방법을 제공함
    - 최근에는 비식별 관계를 주로 사용하는 추세
    - JPA는 식별, 비식별 관계 모두를 지원
    
    ### [4] 조인
    
    **기본은 조인컬럼 사용, 필요시 조인테이블 사용.**
    
    - **조인 컬럼** 사용 (외래키) @JoinColumn
        - 테이블 간의 관계는 주로 조인컬럼이라 부르는 외래키 컬럼을 사용해서 관리한다.
        - 내부조인시 연관관계가 없는 테이블은 조회가 되지 않는 단점(외부조인 사용해야함)
    - **조인 테이블** 사용 (테이블 사용) @JoinTable
        - 테이블을 하나 추가해야 한다는 단점
