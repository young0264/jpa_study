- 3장_영속성 관리 (22.09.08)
    
    > **엔티티 매니저를 통해 엔티티들이 어떻게 동작하는지**
    > 
    
    ### [1] . 엔티티 매니저 팩토리와 엔티티 매니저
    
    - `엔티티 매니저` : 엔티티를 수정 삭제 조회하는 등 엔티티에 관련된 모든일을 처리하는 관리자
    - `엔티티 매니저 팩토리` : 엔티티 매니저를 만드는 공장
    
    ![스크린샷 2022-09-02 09.32.33.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/387b7790-3d5b-4686-a1f5-dc453d47ae17/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-09-02_09.32.33.png)
    
    - 공장 하나를 만드는 비용은 크기때문에 한개만 만들어서 애플리케이션(프로젝트) 전체에 공유하도록 설계되어 있다.
    - 엔티티 매니저(entityManager1)는 데이터베이스 연결이 필요한 시점까지 db의 커넥션을 얻지 않는다. → 트랜잭션을 시작하면 커넥션을 획득
    
    ### [2] . 영속성 컨텍스트
    
    → **엔티티를 영구히 저장하는 환경** 
    
    엔티티 매니저로 `저장` 혹은 `조회`시 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다. 
    
    ```java
    em.persist(member);
    
    → 엔티티 매니저를 사용해서 회원 엔티티를 영속성 컨텍스트에 저장
    ```
    
    - 영속성 컨텍스트는  `논리적 개념`에 가까워 눈으로 확인하기가 어렵다.
    - 영속성 컨텍스트는 엔티티 매니저를 생성할 때 ‘하나' 만들어진다.(여러 매니저가 하나의 컨텍스트에 접근가능)
    - 엔티티 매니저를 통해서 영속성 컨텍스트에 접근 및 관리가 가능하다.
    
    ### [3] . 엔티티의 생명주기
    
    `→ 엔티티에는 4가지 상태가 존재한다`
    
    - **비영속** : 영속성 컨텍스트와 전혀 관계가 없는 상태
        - → 객체를 생성만 한 상태
    - **영속** : **영속성 컨텍스트에** 저장된 상태
        - → 객체를 생성, em.persist가 된 상태
    - **준영속** : 영속성 컨텍스트에 저장되었다가 분리된 상태
        - 영속성 컨텍스트에서 분리된 상태 (ex) em.detach()
    - **삭제** : 삭제된 상태
        - em.remove()
    
    ### [4] . 영속성 컨텍스트의 특징
    
    - **영속성 컨텍스트**는 엔티티를 식별자값(`@Id`로 테이블의 기본키와 매핑한 값으로)으로 구분하기 때문에 영속상태는 **식별자 값**이 반드시 지정해 주어야한다.
    - JPA는(**트랜잭션 커밋시**) 트랜잭션을 `commit`하는 순간 (**커밋전**)`flush` 를 **자동으로 호출**해서 영속성 컨텍스트의 변경 내용을 데이터 베이스에 반영한다.(**데이터베이스에 저장**)
    
    ### 엔티티 조회
    
    ```java
    public class Test01 {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("jpabook");
        EntityManager em = emf.createEntityManager();
    
        public void context() {
            //엔티티 생성
            SiteUser siteUser = new SiteUser();
            siteUser.setId(1L);
            siteUser.setEmail("userEmail01");
            siteUser.setUsername("user01");
    
            //엔티티 영속
            em.persist(siteUser);
    
            //기본 키값으로 영속성컨텍스트에서 엔티티 조회  == 1차캐시에서 조회
            SiteUser siteUser1 = em.find(SiteUser.class, 1L);
    
    				// 1차캐시에 없으면 데이터베이스에서 조회해서 엔티티를 1차캐시에 생성 및 저장.(영속상태)
    				SiteUser siteUser2 = em.find(SiteUser.class, 1L);
    
    				System.out.println(siteUser1==siteUser2); //같은 엔티티 => true
    
    				//커밋하는 순간 데이터베이스에 반영된다.
    				transaction.commit();
    
        }
    }
    ```
    
    - em.find를 호출했을때 먼저 영속성 컨텍스트의 1차캐시에서 엔티티를 찾고 만약 1차캐시에 없으면 데이터베이스에서 조회한다.
    - commit하는 순간까지 데이터 베이스에 저장하지 않고 내부 쿼리 저장소에 INSERT문을 모아두었다가 commit을 할때 DB에 보내는데 이것을 `쓰기지연` 이라 부른다
    - **commit**을 하면 엔티티매니저는 영속성 컨텍스트를 **flush**한다.
        
        (영속성 컨텍스트의 변경내용을 DB에 동기화하는 작업)
        
        등록 수정 삭제 한 내용들을 DB에 반영.
        
        이렇게 `동기화` 한 후에 실제 DB 트랜잭션을 `커밋`한다
        
    
    ### 엔티티 수정
    
    ```java
    SiteUser siteUser1 = em.find(SiteUser.class, 1L);
    
    siteUser1.setEmail("newEmail");
    siteUser1.setPassword("newPassword");
    //업데이트 구문이 없다
    transaction.commit();
    ```
    
    - JPA에서의 엔티티를 수정할 때에는 엔티티를 `조회`해서 데이터만 `변경`하면
        
        `변경감지(dirty checking)`에 의해서 자동으로 데이터베이스에 수정된 값이 반영이 된다.
        
    
    ### 엔티티 삭제
    
    ```java
    SiteUser siteUser1 = em.find(SiteUser.class, 1L);
    em.remove(siteUser1);
    ```
    
    - JPA에서의 엔티티를 수정할 때에는 엔티티를 `조회`해서 em.remove()에 대상 엔티티를 넘겨주면 엔티티를 삭제한다.
    
    ### 플러시
    
    - em.flush()를 해야 DB에 반영이 되는것
    - 별도로 설정하지 않으면 자동으로 커밋이나 쿼리 실행시에 플러시를 자동으로 호출해
    - em.flush를 함으로써 영속성 컨텍스트에 보관된 엔티티를 지우는것이 아니라!, 영속성 컨텍스트의 변경내용을 DB에 동기화, 반영하는것이 플러시이다.
    
    ### 준영속
    
    영속상태 ←→ 준영속상태
    
    - **em.detach() : 특정 엔티티만 준영속 상태로 전환한다.**
        - `detach()` 메소드를 호출하는 순간 `1차캐시`부터 `쓰기지연SQL저장소`의 정보까지 해당 엔티티에 대한 모든 정보가 `제거`된다. ( → DB저장 X)
        
        ```java
        em.persist(member1); // 회원1 엔티티 영속상태
        em.detach(member1);  // 회원1 엔티티 준영속상태(영속성 컨텍스트에서 분리)
        transaction.commit(); //트랜잭션 커밋
        ```
        
    - **em.clear() :  영속성 컨텍스트를 완전히 초기화한다.**
        - 영속성 컨텍스트의 모든 엔티티를 준영속상태로 만든다.
        - 
        
        ```java
        Member member = em.find(Member.class, "member1");//영속상태
        em.clear(); // 영속성 컨텍스트 초기화
        member.setUsername("changedName"); // 준영속상태라 변화 없음
        ```
        
    - **em.close() :  영속성 컨텍스트를 종료한다.**
        - 영속성 컨텍스트를 종료하면 영속성 컨텍스트가 관리하던 영속 상태의 엔티티가 모두 준영속 상태가 된다.
        
    
    ### 정리
    
    - 영속성 컨텍스트는 애플리케이션과 DB사이에서 객체를 보관하는 가상의, 데이터 베이스와같은 역할을 한다고 볼 수 있다(역할적인 면에서)
    - 영속성 컨텍스트덕분에 1차캐시, 동일성보장, 트랜잭션을 지원하는 쓰기지연, 변경감지, 지연로딩등의 기능을 사용할 수 있다.
    - 영속성 컨텍스트에 저장한 엔티티는 flush시점에 DB에 반영되는데 일반적으로는, 트랜잭션을 commit할 때 영속성 컨텍스트가 플러시된다(자동)
    
    ### @Transactional
    
    - 클래스나 메서드단에 이 어노테이션을 붙일 수 있다.
    - 이 어노테이션이 붙어있는 **클래스나 메서드**에 트랜잭션을 적용한다.
    - 외부에서 이 클래스의 **메소드를 호출할 때** 트랜잭션을 **`시작`**하고 메소드가 종료되면 트랜잭션을 `커밋`한다
