- 4장_엔티티 매핑 (22.09.22)
    
    ---
    
    ### 개념정리
    
    ### [1] @Entity, @Table 매핑
    
    - **@Entity** : JPA를 사용해서 테이블과 매핑할 클래스는 `@Entity`어노테이션을 붙여야한다. 엔티티가 붙은 클래스는 `JPA가 관리`하게 된다.
        
        **@Entity의 속성**
        
        - name 속성 : JPA에서 사용할 엔티티 이름을 지정한다. 보통 기본값인 클래스 이름을 사용하고 다른 패키지에 같은 이름의 엔티티 클래스가 있으면 이름을 지정해 주어야 충돌을 방지할 수 있다.
        - @Entity 사용시 주의사항 :
    - **@Table : 엔티티와 매핑할 테이블을 지정한다.**
        
        **(생략하면 매핑한 엔티티 이름을 테이블 이름으로 사용)**
        
        | --- | --- | --- |
        
    
    ### [2] 데이터베이스 스키마 자동 생성
    
    ---
    
    - JPA는 데이터베이스 스키마를 자동으로 생성하는 기능을 지원한다.
    - **테이블중심 → 객체중심** (클래스의 매핑정보를 바탕으로 테이블의 컬럼들을 확인 할 수 있다.)
    - DDL을 애플리케이션 실행 시점에 자동 생성
    - 데이터베이스 방언을 사용해 데이터베이스에 맞는 적절한 DDL생성
    - DDL은 **개발장비에서만 사용**, 운영 서버에서는 사용x or 다듬은 후 사용.
    
    hibernate.hbm2ddl.auto
    
    - `운영장비에는 절대로 create, create-drop, update를 사용하면 안된다.`
    
    | 옵션 | 설명 |
    | --- | --- |
    | create | 기존테이블 삭제 후 다시생성(drop + create) |
    | create-drop | create와 같으나 애플리케이션 종료시점에 생성한 DDL 제거
    (drop + create + drop) |
    | update | DB 테이블과 엔티티 매핑 정보를 비교해서 변경분만 반영
    (운영DB에는 사용 X) |
    | validate | 엔티티와 테이블이 정상 매핑되었는지만 확인 |
    | none | 사용 X |
    
    ### [3] DDL
    
    - 데이터 정의어 (Data Definition Language)
    - 테이블과 같은 데이터 구조를 정의하는데 사용되는 명령어들로 (생성, 변경, 삭제, 이름변경) 등 데이터 구조와 관련된 명령어들을 말함.
    - 스키마 자동생성기를 통해 만들어지는 DDL
    - 제약조건 : 필수입력 , 길이 10자
        
        ****@Column(nullable = false, length = 10)****
        
    - 유니크 제약조건
        - @Table(uniqueConstraints = {@UniqueConstraint( name = "NAME_AGE_UNIQUE", columnNames = {"NAME", "AGE"} )})
    - DDL을 자동생성 할때만 사용되고 **JPA의 실행로직에는 영향을 주지 않음**
    - 이러한 기능을 사용하면 개발자가 엔티티만 보고 다양한 제약조건을 파악할 수 있는 장점이 있다.
    - 이렇게 애플리케이션 실행 동작에는 영향을 주진 않지만 자동생성되는 DDL들이 있다.
    
    ### [4] 기본 키 매핑
    
    - 직접할당 : 기본키 전략 @Id만 사용
    - 자동생성 :
        - IDENTITY : 기본키 생성을 데이터베이스에 위임
        - SEQUENCE : 데이터베이스 시퀀스를 사용해 기본키 생성(할당)
        - TABLE 전략 : 키생성 테이블을 사용
    
    ---
    
    - **기본키 직접 할당 전략**
        - @Id
        - @GeneratedValue
    
    - **IDENTITY 전략**
        - 기본키 생성을 데이터베이스에 위임하는 전략
        - 주로 MySQL, PostgresSQL, SQL Server, DB2에서 사용
        - 이 전략은 기본키를 얻어오기위해 데이터베이스를 조회해서 얻어온다.
        - em.persist 를 하는순간 INSERT SQL이 DB에 전달, 저장된 후
    - **SEQUENCE 전략**
        - 유일한 값을 순서대로 생성하는 특별한 데이터베이스 오브젝트이다.
        - 오라클, PostgresSQL, DB2, H2등에서 사용할 수 있다.
        - @SequenceGenerator 필요
        - IDENTITY 전략과 코드는 유사하지만 내부 동작방식이 다르다.
        - IDENTITY전략은 em.persist()를 하면 엔티티를 DB에 저장한 후 식별자를 조회해서 엔티티를 가져왔다면 **반대로**
        - SEQUENCE 전략은 em.persist()를 호출할 때 먼저 DB시퀀스를 사용해 식별자를 조회하고, 조회한 식별자를 엔티티에 할당한 후에 엔티티를 영속성 컨텍스트에 저장한다. 그리고 transaction 커밋, 플러시가 일어나 DB에 저장한다.
    - **TABLE 전략**
        - 키 생성용 테이블 사용, 모든 DB에서 사용
        - TableGenerator 필요
        ****
    - **AUTO 전략**
        - 방언에 따라 IDENTITY, SEQUENCE, TABLE 전략중 하나를 자동 선택하면 됨
    - **기본키 매핑 정리**
        - 영속성 컨텍스트는 엔티티를 식별자 값으로 구분하므로 엔티티를 영속 상태로 만들려면 반드시 식별자 값이 있어야한다.
        - em.persist()를 호출한 직후에 나타나는 동작들을 전략별로 나눠보면 아래와 같다.
        1. 직접할당
        2. IDENTITY
        3. SEQUENCE
        4. TABLE
        
    
    ### [5] 필드와 컬럼 매핑
    
    | @Column | 컬럼을 매핑 |
    | --- | --- |
    | @Enumerated | 자바의 enum타입 매핑 |
    | @Temporal | 날짜 타입 매핑 |
    | @Lob | BLOB, CLOB 타입을 매핑 |
    | @Transient | 특정 필드를 데이터베이스에 매핑하지 않는다. |
    | @Access | JPA가 엔티티에 접근하는 방식을 지정한다. |
    1. **Column**
        - 객체 필드를 테이블 컬럼에 매핑한다.
        
    2. **Enumerated**
        - 자바 enum타입을 매핑할 때 사용
        - 
        
        | --- | --- | --- |
        
    3. **Temporal**
        - 날짜 타입(java.util.Date, java.util.Calendar)을 매핑할 때 사용
        - 참고: LocalDate, LocalDateTime을 사용할 때는 생략 가능(최신 하이버네이트 지원)
        - 
        
        | --- | --- | --- |
        
    4. **Lob**
    5. **Transient**
    6. **Access**
    
    ---
    
    ### 스터디 토론
    
    - Q. 직접할당이 아닌 자동생성에서 IDENTITY 전략을 실무에서 쓰이는지? 그 장점은?
        - A. IDENTITY 전략 같은경우 기본 키 생성을 데이터베이스에 위임을 하는것이다 보니(ex:AUTO_INCREMENT) 기본키 생성때와 더불어 데이터를 CRUD상황에서 DB에서 또 불러온다는 단점이 있다. 대용량의 데이터를 다룰 상황일 때에는 DB를 더 거친다는 점에서 비용이 크다라는 단점이 생긴다고 볼 수 있다.
    - Q. 프로퍼티 접근법의 장점을 모르겠다.(Getter코드를 직접쓰고 @Id까지 적어줘야 한다는 점에서)
        - A. 두개이상의 column을 primary key로 지정해야 할 경우, 그 두개이상의 요소에 해당한은 getter메서드를 작성한 후 @Id를 붙여주어 프로퍼티 접근법으로 사용?
            
            → 한다해도 번거로워 장점에 대한 결론을 명확히 찾지 못했음.
            
    
    ---
    
    - 주현님이 주신 자료
        
        `@Embeddable` 참고
        
        - [https://velog.io/@fj2008/JPA-복합키-작성기초](https://velog.io/@fj2008/JPA-%EB%B3%B5%ED%95%A9%ED%82%A4-%EC%9E%91%EC%84%B1%EA%B8%B0%EC%B4%88)
        - [https://galid1.tistory.com/592](https://galid1.tistory.com/592)
    
    ---
    
    - 민규님이 주신 자료
    
    <aside>
    💡 지현님 이전에 리뷰 남겨주신 내용 중에 아티클 내 컴포넌트들은 ID Generation를 DB에 의존하지 않고 코드 내에서 SequenceGenerator로 직접 처리한다고 말씀해주셔서 관련 내용을 조금 찾아봤었는데요.
    제가 찾아본 내용 중에 id 값 생성을 DB에 의존하게 되면 INSERT Query 이후에 id 값이 세팅되다보니 이후에 별도로 id 값을 조회하는 과정이 있다라는 부분이 있었고 해당 내용이 직접 처리하는 이유에 가장 가깝다고 생각이 드는 것 같습니다. 혹시 다른 이유가 추가적으로 있을까요?
    
    네, 민규님.
    조금 더 해당 제약을 General하게 표현한다면, "Sequence 생성 프로세스가 DB 장비에 의존성이 생긴다"고 표현 가능할 것 같아요.
    말씀주신 것처럼 신규 Sequence를 획득하기 위해 Select가 발생하는 부분도 그 영향일 수 있겠지만요.
    저희는 글로벌 서비스를 목표로 하는 만큼 추후 DB가 국가별로 나뉜다든가 지역에 따라 Sharding 처리된다든가 하는 경우, 위와 같은 Sequence 획득방식은 제약이 생길 수 밖에 없습니다.
    예를 들어, User라는 사용자 테이블이 있는데, 이것이 국가 또는 지역에 따라 DB 수준 또는 테이블 수준으로 저장 공간이 나뉜다고 생각해볼게요.
    이 경우, Auto increment 방식으로 생성된 Sequence는 각 테이블별로 ID 중복이 발생하는 문제를 해결하기 어렵고요.
    결과적으로 Sequence 생성만을 위한 별도의 테이블을 생성하거나 다른 인프라를 활용해 Sequence를 생성하게 됩니다.
    (하지만 이 역시 Sequence 생성 프로세스가 해당 인프라에 종속되어, 추후 SPOF 요소중에 하나가 될 가능성이 있지요)
    반면, 저희가 현재 선택한 Sequence Generation 방식은 별도의 인프라를 거치지 않고 Application 내부적으로 Unique ID를 생성하는 방식인 만큼, 특정 인프라에 대한 의존도가 없다는 장점이 있습니다.
    사실 어느 한 방식이 정답이라고 강요할 수는 없고요.
    앞의 DB 수준의 Sequence Generation 방식도 현업에서 많이 쓰시는 방식이기는 합니다.
    장단점을 잘 알고 쓰시면, 그걸로 충분한 것 같아요.
    
    </aside>
    
    ###
